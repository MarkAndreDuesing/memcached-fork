//Implementations:

//strtoull (only need to do for base 10):

//\todo{remember to add a implelementation idea here!!! Double check that the implementation follows all the specified behaviour}

//\\Implelementation from \url{https://github.com/torvalds/linux/blob/master/arch/powerpc/boot/stdlib.c#L13}:
//\begin{lstlisting}[breaklines=true]
#include "stdlib.h"

/* Not currently supported: leading whitespace, sign, 0x prefix, zero base */
unsigned long long int strtoull(const char *ptr, char **end, int base)
{
	unsigned long long ret = 0;

	if (base > 36)
		goto out;

	while (*ptr) {
		int digit;

		if (*ptr >= '0' && *ptr <= '9' && *ptr < '0' + base)
			digit = *ptr - '0';
		else if (*ptr >= 'A' && *ptr < 'A' + base - 10)
			digit = *ptr - 'A' + 10;
		else if (*ptr >= 'a' && *ptr < 'a' + base - 10)
			digit = *ptr - 'a' + 10;
		else
			break;

		ret *= base;
		ret += digit;
		ptr++;
	}

out:
	if (end)
		*end = (char *)ptr;

	return ret;
}
//\end{lstlisting}

//\\Or auto generated by Chat-GPT (test for correctness first!!!):
//\begin{lstlisting}[breaklines=true]
#include <stddef.h>
#include <stdint.h>

unsigned long long strtoull(const char *str, char **endptr, int base) {
    // Implementation of strtoull
    // This is a basic implementation for illustrative purposes

    // Placeholder values
    unsigned long long result = 0;
    int digit;

    // Handle invalid base
    if (base < 0 || (base != 0 && (base < 2 || base > 36))) {
        if (endptr != NULL) {
            *endptr = (char *)str;
        }
        return 0;
    }

    // Skip leading whitespace
    while (*str && (*str == ' ' || *str == '\t' || *str == '\n' || *str == '\r')) {
        str++;
    }

    // Determine the base if not specified
    if (base == 0) {
        if (*str == '0') {
            if (str[1] == 'x' || str[1] == 'X') {
                base = 16;
                str += 2;
            } else {
                base = 8;
                str++;
            }
        } else {
            base = 10;
        }
    }

    // Main conversion loop
    while (*str) {
        if (*str >= '0' && *str <= '9') {
            digit = *str - '0';
        } else if (*str >= 'a' && *str <= 'z') {
            digit = *str - 'a' + 10;
        } else if (*str >= 'A' && *str <= 'Z') {
            digit = *str - 'A' + 10;
        } else {
            break;
        }

        if (digit >= base) {
            break;
        }

        result = result * base + digit;
        str++;
    }

    // Set endptr if provided
    if (endptr != NULL) {
        *endptr = (char *)str;
    }

    return result;
}
//\end{lstlisting}
//\\Or:
//\begin{lstlisting}
#include <ctype.h>
#include <errno.h>
#include <limits.h>
#include <stdlib.h>

unsigned long long strtoull(const char *str, char **endptr, int base) {
// Check for invalid base
    if (base < 0 || (base != 0 && (base < 2 || base > 36))) {
        errno = EINVAL;  // Invalid argument
        if (endptr != NULL) {
            *endptr = (char *)str;
        }
        return 0;
    }

    // Skip leading whitespace
    while (isspace((unsigned char)*str)) {
        str++;
    }

    // Determine the base if not specified
    if (base == 0) {
        if (*str == '0') {
            base = (str[1] == 'x' || str[1] == 'X') ? 16 : 8;
            if (base == 16) {
                str += 2;  // Skip "0x" or "0X"
            } else {
                str++;  // Skip "0"
            }
        } else {
            base = 10;
        }
    }

    // Initialize variables
    unsigned long long result = 0;
    int digit;
    unsigned long long maxDiv = ULLONG_MAX / base;
    unsigned long long maxRem = ULLONG_MAX % base;

    // Main conversion loop
    while (*str) {
        // Convert character to digit
        if (isdigit((unsigned char)*str)) {
            digit = *str - '0';
        } else if (isalpha((unsigned char)*str)) {
            digit = tolower((unsigned char)*str) - 'a' + 10;
        } else {
            break;
        }

        // Check for invalid digit for the given base
        if (digit >= base) {
            if (endptr != NULL) {
                *endptr = (char *)str;
            }
            errno = EINVAL;  // Invalid argument
            return ULLONG_MAX;
        }

        // Check for overflow
        if (result > maxDiv || (result == maxDiv && digit > maxRem)) {
            errno = ERANGE;  // Result too large
            if (endptr != NULL) {
                *endptr = (char *)str;
            }
            return ULLONG_MAX;
        }

        // Update result
        result = result * base + digit;

        // Move to the next character
        str++;
    }

    // Set endptr if provided
    if (endptr != NULL) {
        *endptr = (char *)str;
    }

    return result;
}

// Example usage
#include <stdio.h>

int main() {
    const char *str = "12345";
    char *endptr;
    unsigned long long result = strtoull(str, &endptr, 10);

    if (endptr != str) {
        printf("Converted value: %llu\n", result);
        printf("Remaining string: %s\n", endptr);
    } else {
        perror("strtoull");
    }

    return 0;
}

//\end{lstlisting}
